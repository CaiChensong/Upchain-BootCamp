## 理解合约升级涉及的存储布局

### 题目#1

编写可升级合约时，如果第一个版本逻辑实现合约中有一个 mapping（ uint -> User） users ; User 是一个结构体类型，请问在第二个版本的逻辑实现合约，可否在 User 结构体里添加一个变量？ 请说出你的理解。

回答：
可以。
在 EVM 中，mapping 中各个键值对使用的存储空间是离散的，所以虽然增加变量可能会导致单个结构体使用的存储空间变大，但是在不会影响已有存储空间的情况下，是可以新增变量的。

### 题目#2

编写可升级合约时，如果第一个版本逻辑实现合约中有一个数组 User[] users ; User 是一个结构体类型，请问在第二个版本的逻辑实现合约，可否在 User 结构体里添加一个变量？ 请说出你的理解。

回答：
不可以。
在 EVM 中，数组在存储时是整个数组连续存储的，同时结构体的所有字段也是连续存储的，如果 User 结构体的字段总大小 ≤ 32 字节，所有字段打包在一个槽中；如果 > 32 字节，会跨多个槽存储。
在结构体中增加变量可能会导致整个结构体的存储空间变大，这种情况下会连锁影响后续所有元素，导致整个数组数据被覆盖或损坏。
所以除非增加的变量不会导致结构体使用的存储插槽溢出，才可以增加变量，否则不能增加变量。

### 题目#3

编写可升级合约时，如果逻辑实现合约有继承关系，什么情况下能向父合约里添加变量？ 你认为的最佳实践是什么？

回答：
继承合约的存储布局是父合约和子合约存储布局的组合，存储槽按照继承顺序分配：先父合约，后子合约。所以往父合约中添加变量，会导致子合约的存储位置发生偏移。如果想安全地向父合约中添加变量，大概可以有这几种方式：

- 子合约中没有状态变量，这样添加变量相对安全
- 手动把添加的变量存储位置放到父合约的存储空间的远端，确保不会影响现有变量的存储位置
- 最佳实践：在父合约中预留足够的存储槽，比如：
  ```solidity
   contract Parent {
       // 预留存储间隙
       uint256[50] private __gap;
   }
  ```
